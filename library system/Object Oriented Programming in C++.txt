This book teaches you how to program in C++ a computer language that supports object oriented programming OOP Why do we need OOP What does it do that traditional lan guages such as C Pascal and BASIC don’t What are the principles behind OOP Two key concepts in OOP are objects and classes What do these terms mean What is the relationship between C++ and the older C language This chapter explores these questions and provides an overview of the features to be discussed in the balance of the book What we say here will necessarily be rather general although mercifully brief If you find the discussion somewhat abstract don’t worry The concepts we men tion here will come into focus as we demonstrate them in detail in subsequent chapters Why Do We Need Object Oriented Programming Object oriented programming was developed because limitations were discovered in earlier approaches to programming To appreciate what OOP does we need to under stand what these limitations are and how they arose from traditional programming languages Procedural Languages C Pascal FORTRAN and similar languages are procedural languages That is each statement in the language tells the computer to do something Get some input add these numbers divide by six display that output A program in a procedural language is a list of instructions For very small programs no other organizing principle often called a paradigm is needed The programmer creates the list of instructions and the computer carries them out Division into Functions When programs become larger a single list of instructions becomes unwieldy Few programmers can comprehend a program of more than a few hundred statements unless it is broken down into smaller units For this reason the function was adopted as a way to make programs more comprehensible to their human creators The term function is used in C++ and C In other languages the same concept may be referred to as a subroutine a subprogram or a procedure A procedural program is divided into functions and ideally at least each function has a clearly defined purpose and a clearly defined interface to the other functions in the program The idea of breaking a program into functions can be further extended by grouping a number of functions together into a larger entity called a module which is often a file but the principle is similar a grouping of components that execute lists of instructions Dividing a program into functions and modules is one of the cornerstones of structured programming the somewhat loosely defined discipline that influenced programming organization for several decades before the advent of object oriented programming Problems with Structured Programming As programs grow ever larger and more complex even the structured programming approach begins to show signs of strain You may have heard about or been involved in horror stories of program development The project is too complex the schedule slips more programmers are added complexity increases costs skyrocket the schedule slips further and disaster ensues See The Mythical Man Month by Frederick Addison Wesley 1982 for a vivid description of this process Analyzing the reasons for these failures reveals that there are weaknesses in the procedural paradigm itself No matter how well the structured programming approach is implemented large programs become excessively complex What are the reasons for these problems with procedural languages There are two related problems First functions have unrestricted access to global data Second unrelated functions and data the basis of the procedural paradigm provide a poor model of the real world Let’s examine these problems in the context of an inventory program One important global data item in such a program is the collection of items in the inventory Various functions access this data to input a new item display an item modify an item and so on Unrestricted Access In a procedural program one written in C for example there are two kinds of data Local data is hidden inside a function and is used exclusively by the function In the inventory program a display function might use local data to remember which item it was displaying Local data is closely related to its function and is safe from modification by other functions However when two or more functions must access the same data and this is true of the most important data in a program then the data must be made global as our collection of inven tory items is Global data can be accessed by any function in the program We ignore the issue of grouping functions into modules which doesn’t materially affect our argument For example in our inventory program someone may decide that the product codes for the inventory items should be changed from 5 digits to 12 digits This may necessitate a change from a short to a long data type Now all the functions that operate on the data must be modified to deal with a long instead of a short Everyone who patronizes the supermarket must then figure out where the bread has gone and adjust their shopping habits accordingly When data items are modified in a large program it may not be easy to tell which functions access the data and even when you figure this out modifications to the functions may cause them to work incorrectly with other global data items Everything is related to everything else so a modification anywhere has far reaching and often unintended consequences Real World Modeling The second and more important problem with the procedural paradigm is that its arrangement of separate data and functions does a poor job of modeling things in the real world In the physical world we deal with objects such as people and cars Such objects aren’t like data and they aren’t like functions Complex real world objects have both attributes and behavior Attributes Examples of attributes sometimes called characteristics are for people eye color and job title and for cars horsepower and number of doors As it turns out attributes in the real world are equivalent to data in a program they have a certain specific values such as blue for eye color or four for the number of doors Behavior is something a real world object does in response to some stimulus If you ask your boss for a raise she will generally say yes or no If you apply the brakes in a car it will generally stop Saying something and stopping are examples of behavior Behavior is like a function you call a function to do something display the inventory for example and it does it So neither data nor functions by themselves model real world objects effectively The Object Oriented Approach The fundamental idea behind object oriented languages is to combine into a single unit both data and the functions that operate on that data Such a unit is called an object